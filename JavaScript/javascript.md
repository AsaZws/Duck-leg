# JavaScript--
js高级程序设计第三版第五章开始的学习之路
## 第五章 => 引用类型
### 5.2 => Array类型
#### 5.2.6 => 操作方法
    concat()
    基于当前数组中的所有项创建一个新数组添加到后面
    slice()
    基于当前数组，传入参数，返回从该指定位置到当前数组末尾的所有项，
    如果有两个参数，返回起始位置和结束位置之间的项，但不包括结束位置的项
    splice()
    删除 => 指定两个参数，要删除的第一项的位置和要删除的项数
    插入 => 指定三个参数，起始位置，0（要删除的项数），和要插入的项
    替换 => 指定三个参数，起始位置，要删除的项数和要插入的项
#### 5.2.7 => 位置方法
    indexOf()
    从数组前面开始查找
    lastIndexOf()
    从数组后面开始查找，如果只给一个参数，则从0项开始查找，如果传如两个参数，则要严格相等
#### 5.2.8 => 迭代方法
    every()
    对数组中的每一项运行给定函数，如果对每一项都返回true，则返回true
    some()
    对数组中的每一项运行给定函数，如果对某一项都返回true，则返回true
    filter()
    对数组中的每一项运行给定函数，给返回true的项组成新的数组
    map()
    对数组的每一项运行给定函数，返回每次函数调用的结果组成的函数
    forEach()
    对数组中的每一项运行传入函数，没有返回值，本质上与for循环迭代数组一样
#### 5.2.9 => 归并方法
    reduce()
    迭代数组所有的项，从数组第一项开始
    reducsRight()
    迭代数组所有的项，从数组最后一项开始
### 5.4 => RegExp类型
    g: => 全局模式
    i: => 不区分大小写
    m: => 表示多行模式
### 5.5 => Function类型
    函数名也是指向函数对象的指针
#### 5.5.1 => 没有重载
#### 5.5.2 => 声明与表达式
    函数声明提升
    函数可以作为值传递
#### 5.5.4 => 函数的内部属性
    arguments => 保存函数的参数
    this => 指针
    arguments.callee => 可以指向对象函数，完成递归调用,改变指向
    caller => 保存着调用当前函数的函数引用，严格模式下不能赋值
#### 5.5.5 => 函数属性和方法
    每个函数都包含length和prototype
    apply() => 接受两个参数，一个在其中运行的作用域，另一个是参数数组Array()
    严格模式下，未指定环境对象而调用对象，this会指向undefined
    call() => 与apply不同的是传递的参数必须逐个列出来
    call()还可以扩充函数依赖于运行的作用域
    bind() => 创建一个函数的实例，其中this的值会绑定传给bind()函数的值
### 5.6 => 基本包装类型
    对象只存在一行代码的执行瞬间，然后立即被销毁
    对基本包装类型的实例调用typeof会返回"object"，对所有基本包装类型的对象转换为布尔值时都是true
#### 5.6.1 => Boolean
    布尔表达式中所有对象都会被转换成true
    typeof => 操作符对基本类型返回"boolean"，对引用类型返回"object"
#### 5.6.2 => Number
    要创建Number对象，可以在调用Number构造函数时向其传递相应的数值
#### 5.6.3 => String
    charAt() => 可以获取字符串中给定位置的那个字母
    emememem...
## 6 => 面向对象的程序设计
    一组名值对，其中可以是数据或函数
### 6.1 => 理解对象
    创建一个Object实例，然后添加属性和方法
#### 6.1.1 => 属性类型
    1.数据属性 => 读取和写入，delete删除重新写入，for-in循环，修改属性，读写
    writable => 这个值设定为true会改变修改的值
    2.访问器属性 => 不包含数据值
    "_"只能通过对象访问的属性符号
#### 6.1.2 => 属性类型
    Object.definePro-perties() => 一次性定义多个属性，接收两个参数
#### 6.1.3 => 读取属性的特性
    Object.getOwnPropertyDescriptor() => 接收两个参数，属性所在对象和要读取其描述符的属性名称
### 6.2 => 创建对象
#### 6.2.1 => 工厂模式
    用函数来封装以特定接口创建对象的细节
#### 6.2.2 => 构造函数模式
    构造函数以大写字母开头
    1.创建一个新对象
    2.将构造函数的作用域赋给新对象（此时this就指向了这个新对象）
    3.执行构造函数中的代码
    4.返回新对象
    instanceof => 检测对象类型
#### 6.2.3 => 原型模式
    prototype就是通过构造函数而创建的那个对象实例的原型对象，好处是让所有对象实例共享它所包含的属性和方法
    hasOwnProperty => 检测是否访问的原型返回false
    我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法
    调用"name" in person1 始终都会返回true
    同时使用hasOwnProperty()方法和in操作符，就可以确定该属性到底是存在于对象中还是存在于原型中  => 
    function hasWonPrototyperty(object, name) {
        return !object.hasOwnProperty(name) && (name in object);
    }

#### 理解this
    1.作为普通对象调用
    2.作为普通函数调用
    3.构造器调用
    4.Function.prototype.call或Function.prototype.apply调用
    

    
    
    
    